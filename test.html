<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI-Powered C Compiler</title>
  <link rel="stylesheet" href="stylesheet1.css">
  <style>
    /* Basic styling for tree and errors */
    .tree-node { border: 1px solid #666; padding: 5px; margin: 5px; display: inline-block; vertical-align: top; }
    .node-label { font-weight: bold; }
    .children { margin-left: 20px; }
    .error { color: red; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 5px; text-align: left; }
  </style>
</head>
<body>
  <h2>AI-Powered C Compiler</h2>

  <input id="promptInput" placeholder="Describe code (e.g. check prime number)" style="width: 70%; padding: 5px;" />
  <button onclick="generateCodeFromPrompt()">🪄 Generate Code</button><br /><br>

  <textarea id="codeInput" placeholder="Enter C code here..." rows="10" style="width: 100%;"></textarea><br /><br>
  <button onclick="analyzeCode()">Run Compiler</button>
  <button onclick="explainCode()">Explain Code</button>
  <button onclick="fixCode()">🛠 Auto Fix</button>
  <button onclick="predictOutput()">Predict Output</button>

  <div class="section"><h3>Lexical Analysis (Tokens)</h3><ul id="tokensList"></ul></div>
  <div class="section"><h3>Syntax Errors</h3><ul id="syntaxList"></ul></div>
  <div class="section"><h3>Semantic Errors</h3><ul id="semanticList"></ul></div>
  <div class="section"><h3>Symbol Table</h3><div id="symbolTable"></div></div>
  <div class="section"><h3>Parse Tree</h3><div id="parseTreeOutput"></div></div>
  <div class="section"><h3>AI Explanation</h3><pre id="explanation"></pre></div>
  <div class="section"><h3>AI Fixed Code</h3><pre id="fixedCode"></pre></div>
  <div class="section"><h3>Predicted Output</h3><pre id="predictedOutput"></pre></div>
  <div class="section"><h3>Intermediate Code (TAC)</h3><pre id="intermediateCode"></pre></div>
  <div class="section"><h3>Optimized Intermediate Code (After Optimization)</h3><pre id="optimizedCode"></pre></div>

  <script>
    async function getAISuggestion(message) {
      try {
        const res = await fetch("http://localhost:3000/suggest", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message })
        });
        const data = await res.json();
        return data.suggestion || "No suggestion received.";
      } catch {
        return "❌ Failed to connect to AI server.";
      }
    }

    async function generateCodeFromPrompt() {
      const prompt = document.getElementById("promptInput").value;
      if (!prompt.trim()) {
        alert("Please describe what code to generate.");
        return;
      }
      const message = `Write a C program for: ${prompt}`;
      const code = await getAISuggestion(message);
      document.getElementById("codeInput").value = code;
    }

    class TreeNode {
      constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
      }
    }

    function renderTreeDOM(node) {
      if (!node) return null;
      const elem = document.createElement("div");
      elem.classList.add("tree-node");

      const label = document.createElement("div");
      label.classList.add("node-label");
      label.innerText = node.value;

      const container = document.createElement("div");
      container.classList.add("children");

      if (node.left) container.appendChild(renderTreeDOM(node.left));
      if (node.right) container.appendChild(renderTreeDOM(node.right));

      elem.appendChild(label);
      if (node.left || node.right) elem.appendChild(container);
      return elem;
    }

    function generateParseTree(code) {
      const treeContainer = document.getElementById("parseTreeOutput");
      treeContainer.innerHTML = "";

      const lines = code.split('\n').map(line => line.trim()).filter(Boolean);
      const lastLine = lines.reverse().find(line => line.includes('=') && /[+\-*/]/.test(line));

      if (!lastLine) {
        treeContainer.innerText = "❌ Only supports simple expressions like: a = b + c;";
        return;
      }

      const match = lastLine.match(/(\w+)\s*=\s*(\w+|\d+)\s*([+\-*/])\s*(\w+|\d+);?/);
      if (!match) {
        treeContainer.innerText = "❌ Unable to parse expression.";
        return;
      }

      const [_, lhs, op1, operator, op2] = match;
      const root = new TreeNode("=");
      root.left = new TreeNode(lhs);

      const opNode = new TreeNode(operator);
      opNode.left = new TreeNode(op1);
      opNode.right = new TreeNode(op2);

      root.right = opNode;
      const domTree = renderTreeDOM(root);
      treeContainer.appendChild(domTree);
    }

    function generateIntermediateCode(code) {
      const output = [];
      let tempVarCount = 1;

      const lines = code.split('\n').map(line => line.trim()).filter(Boolean);

      lines.forEach(line => {
        const match = line.match(/^(\w+)\s*=\s*(\w+|\d+)\s*([+\-*/])\s*(\w+|\d+);?$/);
        if (match) {
          const [_, lhs, op1, operator, op2] = match;

          if (!isNaN(op1) && !isNaN(op2)) {
            // Constant folding
            const result = eval(`${op1} ${operator} ${op2}`);
            output.push(`${lhs} = ${result}`);
          } else {
            const temp = `t${tempVarCount++}`;
            output.push(`${temp} = ${op1} ${operator} ${op2}`);
            output.push(`${lhs} = ${temp}`);
          }
        }
      });

      return output;
    }

    // Optimization function - does constant folding and removes redundant temps
    function optimizeIntermediateCode(codeLines) {
      // Simple constant folding already done, so here we do basic temp removal:
      // If pattern is: t1 = x op y; followed by a = t1; => combine to a = x op y;
      const optimized = [];
      for (let i = 0; i < codeLines.length; i++) {
        const line = codeLines[i];
        const assignTempMatch = line.match(/^(t\d+)\s*=\s*(.+)$/);
        if (assignTempMatch && i + 1 < codeLines.length) {
          const tempVar = assignTempMatch[1];
          const expr = assignTempMatch[2];

          const nextLine = codeLines[i + 1];
          const assignVarMatch = nextLine.match(/^(\w+)\s*=\s*(t\d+)$/);

          if (assignVarMatch && assignVarMatch[2] === tempVar) {
            // Replace next line with optimized assignment
            optimized.push(`${assignVarMatch[1]} = ${expr}`);
            i++; // Skip next line
            continue;
          }
        }
        optimized.push(line);
      }
      return optimized;
    }

    function analyzeCode() {
      const code = document.getElementById("codeInput").value;
      let tokens = [], syntaxErrors = [], semanticErrors = [];

      const keywords = ["int", "float", "char", "if", "else", "while", "return"];
      const operators = ["==", "!=", "<=", ">=", "=", "+", "-", "*", "/"];
      const symbols = ["{", "}", "(", ")", ";", ","];

      // Symbol Table: { varName: { type: string, initialized: boolean } }
      const symbolTable = {};

      const declaredVariables = new Set();
      const variableTypes = {};

      const tokenMatches = code.match(/\b(int|float|char|if|else|while|return)\b|==|!=|<=|>=|=|[+\-*\/]|[{}();,]|[a-zA-Z_]\w*|\d+/g);
      if (tokenMatches) {
        tokens = tokenMatches;
      }

      // Syntax check: semicolons at line ends & balanced braces
      const lines = code.split('\n');

      // Braces stack for syntax check
      const braceStack = [];
      lines.forEach((line, idx) => {
        const trimmed = line.trim();
        if (!trimmed) return;

        // Check for missing semicolon (except lines ending with { or } or blank or preprocessor)
        if (!trimmed.endsWith(';') && !trimmed.endsWith('{') && !trimmed.endsWith('}') && !trimmed.startsWith('#')) {
          syntaxErrors.push(`Line ${idx + 1}: Missing semicolon.`);
        }

        // Check balanced braces
        for (let ch of trimmed) {
          if (ch === '{') braceStack.push('{');
          else if (ch === '}') {
            if (braceStack.length === 0) syntaxErrors.push(`Line ${idx + 1}: Unmatched '}' found.`);
            else braceStack.pop();
          }
        }

        // Very simple variable declaration check:
        const declMatch = trimmed.match(/^(int|float|char)\s+([a-zA-Z_]\w*)\s*(=\s*[^;]+)?;/);
        if (declMatch) {
          const [_, type, varName, initPart] = declMatch;
          declaredVariables.add(varName);
          variableTypes[varName] = type;
          symbolTable[varName] = {
            type,
            initialized: !!initPart
          };
        }

        // Check usage of variables - if used before declaration
        const usageMatches = trimmed.match(/\b[a-zA-Z_]\w*\b/g);
        if (usageMatches) {
          usageMatches.forEach(token => {
            if (!keywords.includes(token) && !declaredVariables.has(token) && isNaN(token)) {
              semanticErrors.push(`Line ${idx + 1}: Variable "${token}" used before declaration.`);
            }
          });
        }
      });

      if (braceStack.length > 0) {
        syntaxErrors.push("Unmatched '{' found.");
      }

      // Show results
      const tokensList = document.getElementById("tokensList");
      tokensList.innerHTML = "";
      tokens.forEach(tok => {
        const li = document.createElement("li");
        li.textContent = tok;
        tokensList.appendChild(li);
      });

      const syntaxList = document.getElementById("syntaxList");
      syntaxList.innerHTML = "";
      if (syntaxErrors.length) {
        syntaxErrors.forEach(err => {
          const li = document.createElement("li");
          li.textContent = err;
          li.classList.add("error");
          syntaxList.appendChild(li);
        });
      } else {
        syntaxList.innerHTML = "<li>✅ No syntax errors found.</li>";
      }

      const semanticList = document.getElementById("semanticList");
      semanticList.innerHTML = "";
      if (semanticErrors.length) {
        semanticErrors.forEach(err => {
          const li = document.createElement("li");
          li.textContent = err;
          li.classList.add("error");
          semanticList.appendChild(li);
        });
      } else {
        semanticList.innerHTML = "<li>✅ No semantic errors found.</li>";
      }

      // Show symbol table
      const symbolTableDiv = document.getElementById("symbolTable");
      let tableHtml = `<table><tr><th>Variable</th><th>Type</th><th>Initialized</th></tr>`;
      for (const [name, info] of Object.entries(symbolTable)) {
        tableHtml += `<tr><td>${name}</td><td>${info.type}</td><td>${info.initialized ? "Yes" : "No"}</td></tr>`;
      }
      tableHtml += "</table>";
      symbolTableDiv.innerHTML = tableHtml;

      // Generate parse tree
      generateParseTree(code);

      // Generate intermediate code
      const intermediateCodeLines = generateIntermediateCode(code);
      document.getElementById("intermediateCode").textContent = intermediateCodeLines.join("\n");

      // Optimization phase
      const optimizedCodeLines = optimizeIntermediateCode(intermediateCodeLines);
      document.getElementById("optimizedCode").textContent = optimizedCodeLines.join("\n");
    }

    async function explainCode() {
      const code = document.getElementById("codeInput").value;
      const explanation = await getAISuggestion(`Explain this C code:\n\n${code}`);
      document.getElementById("explanation").textContent = explanation;
    }

    async function fixCode() {
      const code = document.getElementById("codeInput").value;
      const fixed = await getAISuggestion(`Fix errors in this C code:\n\n${code}`);
      document.getElementById("fixedCode").textContent = fixed;
    }

    async function predictOutput() {
      const code = document.getElementById("codeInput").value;
      const output = await getAISuggestion(`Predict the output of this C code:\n\n${code}`);
      document.getElementById("predictedOutput").textContent = output;
    }
  </script>
</body>
</html>
